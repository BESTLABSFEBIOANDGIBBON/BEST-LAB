
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>meshDistMarch</title><meta name="generator" content="MATLAB 9.6"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2019-06-20"><meta name="DC.source" content="HELP_meshDistMarch.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>meshDistMarch</h1><!--introduction--><p>Below is a demonstration of the features of the <tt>meshDistMarch</tt> function</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#2">Syntax</a></li><li><a href="#3">Description</a></li><li><a href="#4">Examples</a></li><li><a href="#6">Example: Edge or graph data</a></li><li><a href="#10">Example: Triangulated data</a></li><li><a href="#14">Example: Quadrangulated data</a></li><li><a href="#18">Example: Hexahedral mesh data</a></li><li><a href="#22">Example: Tetrahedral mesh data</a></li><li><a href="#26">Example: Mesh types effecting marching based distance computation</a></li><li><a href="#30">Example: Using <tt>meshDistMarch</tt> for geodesic point sampling</a></li><li><a href="#34">Example: Using <tt>meshDistMarch</tt> for geodesic surface resampling</a></li><li><a href="#36">Example: Using unit edge lengths</a></li></ul></div><pre class="codeinput">clear; close <span class="string">all</span>; clc;
</pre><h2 id="2">Syntax</h2><p><tt>[d,seedIndex]=meshDistMarch(F,V,indStart,optionStruct);</tt></p><h2 id="3">Description</h2><p>The meshDistMarch function can be used to compute distances on meshes. The distances can be used for points sampling on the mesh or for remeshing. The function can operate on edge descriptions or face descriptions. Therefore for volumetric meshes (e.g. consisting of tetrahedra or hexahedra) appropriate face or edge data should be computed first to formulate the input.</p><p>Input: E: the edges or faces for the mesh. E.g. an nx2 edge matrix or an nxm face matrix (n faces, m corners per face) V: the vertices for the mesh indStart: indices for one or more points to compute distances from optionStruct.toleranceLevel : The tolerance level for convergence. 0 is the default. optionStruct.numSeeds: Defines the number of seeds to generate on the mesh. Default is equal to startInd. optionStruct.waitBarOn=0; %Turn on/off waitbar optionStruct.unitEdgeOn=1; %Turn on/off the use of unit edge lengths</p><p>Output: d: distances (from the start/seed points) on the mesh vertices seedIndex: nearest seed (or start) point indices for each vertex, forming a quasi-Voronoi tesselation. If the second output is not requested the performance is enhanced.</p><h2 id="4">Examples</h2><p>Plot settings</p><pre class="codeinput">cMapDist=flipud(igviridis(250));
[cMapIndices,scrambleIndices]=scramble(viridis(250),1); <span class="comment">%Colormap</span>

faceAlpha1=1;
faceAlpha2=0.65;
fontSize=25;
markerSize=50;
</pre><h2 id="6">Example: Edge or graph data</h2><p>Create branching example. E defines edges and V is a vertex array</p><pre class="codeinput">n=75;
x=linspace(0,0.9*pi,n);
y=sin(x);
V=[x(:) y(:) zeros(size(x(:)))];
V=evenlySampleCurve(V,n,<span class="string">'pchip'</span>,0);
x=V(:,1);
y=V(:,2);
dV=vecnormalize(diff(V,1,1));
VdV=V(1:1:end-1,:);
placePoints=1:3:n-1;
E=[(1:1:n-1)' (2:1:n)'];
numSteps=numel(placePoints);
l=linspace(0.75,0.25,numSteps);
a=linspace(0.25*pi,0.25*pi,numSteps);
<span class="keyword">for</span> q=1:1:numSteps
    R=euler2DCM([0 0 a(q)]);
    vr1=dV(placePoints(q),:)*R.*l(q);
    vr2=dV(placePoints(q),:)*R'.*l(q);
    Vb=linspacen([x(placePoints(q)) y(placePoints(q)) 0],vr1+[x(placePoints(q)) y(placePoints(q)) 0],n)';
    Eb=[(1:1:n-1)' (2:1:n)'];
    E=[E; Eb+size(V,1)];
    V=[V; Vb];
    Vb=linspacen([x(placePoints(q)) y(placePoints(q)) 0],vr2+[x(placePoints(q)) y(placePoints(q)) 0],n)';
    Eb=[(1:1:n-1)' (2:1:n)'];
    E=[E; Eb+size(V,1)];
    V=[V; Vb];
<span class="keyword">end</span>
E=[E;E+size(V,1);];
V2=V;
V2(:,2)=-V2(:,2);
V2(:,1)=-V2(:,1);
V=[V;V2];
E=[E;E+size(V,1);];
V2=V;
V2(:,2)=-V2(:,2);
V=[V;V2];
[E,V]=mergeVertices(E,V);
</pre><p>Compute distances on mesh</p><pre class="codeinput"><span class="comment">%Option set</span>
indStart=1; <span class="comment">%Index of the start point</span>
optionStruct.toleranceLevel=0; <span class="comment">%Tolerance for convergence</span>
optionStruct.numSeeds=1; <span class="comment">%Number of seeds</span>
optionStruct.waitBarOn=0; <span class="comment">%Turn on/off waitbar</span>

<span class="comment">%Compute distances on mesh description</span>
d=meshDistMarch(E,V,indStart,optionStruct);
</pre><p>Visualization</p><pre class="codeinput">cFigure; hold <span class="string">on</span>;
title(<span class="string">'Distances on an edge / graph model'</span>,<span class="string">'fontSize'</span>,fontSize);
hp(1)=gpatch(E,V,<span class="string">'none'</span>,d,1,4);
hp(2)=plotV(V(indStart,:),<span class="string">'k.'</span>,<span class="string">'MarkerSize'</span>,markerSize);
legend(hp,{<span class="string">'Mesh distances'</span>,<span class="string">'Start point(s)'</span>},<span class="string">'Location'</span>,<span class="string">'SouthOutSide'</span>);
axisGeom;
view(2);
colorbar;
drawnow;
</pre><img width="100%" height="auto" vspace="5" hspace="5" src="HELP_meshDistMarch_01.jpg" alt=""> <h2 id="10">Example: Triangulated data</h2><p>Get example triangulated mesh data</p><pre class="codeinput">[F,V]=stanford_bunny;<span class="comment">%graphicsModels(1);</span>
</pre><p>Compute distances on mesh</p><pre class="codeinput"><span class="comment">%Option set</span>
[~,indStart]=min(V(:,1)); <span class="comment">%Index of the start point</span>
optionStruct.toleranceLevel=0; <span class="comment">%Tolerance for convergence</span>
optionStruct.numSeeds=1; <span class="comment">%Number of seeds</span>
optionStruct.waitBarOn=0; <span class="comment">%Turn on/off waitbar</span>

<span class="comment">%Compute distances on mesh description</span>
d=meshDistMarch(F,V,indStart,optionStruct);
</pre><p>Visualization</p><pre class="codeinput">cFigure;
subplot(1,2,1);hold <span class="string">on</span>;
title(<span class="string">'Distances on a triangulated surface model'</span>,<span class="string">'fontSize'</span>,fontSize);
gpatch(F,V,<span class="string">'kw'</span>,d,1);
hp(1)=gpatch(F,V,<span class="string">'none'</span>,d,1,2);
hp(2)=plotV(V(indStart,:),<span class="string">'k.'</span>,<span class="string">'MarkerSize'</span>,markerSize);
legend(hp,{<span class="string">'Mesh distances'</span>,<span class="string">'Start point(s)'</span>},<span class="string">'Location'</span>,<span class="string">'SouthOutSide'</span>);
axisGeom;
colorbar;
camlight <span class="string">headlight</span>;

subplot(1,2,2);hold <span class="string">on</span>;
title(<span class="string">'Distances on a triangulated surface model'</span>,<span class="string">'fontSize'</span>,fontSize);
hp(1)=gpatch(F,V,d,<span class="string">'none'</span>,1);
hp(2)=plotV(V(indStart,:),<span class="string">'k.'</span>,<span class="string">'MarkerSize'</span>,markerSize);
legend(hp,{<span class="string">'Mesh distances'</span>,<span class="string">'Start point(s)'</span>},<span class="string">'Location'</span>,<span class="string">'SouthOutSide'</span>);
axisGeom;
camlight <span class="string">headlight</span>;
colorbar;
drawnow;
</pre><img width="100%" height="auto" vspace="5" hspace="5" src="HELP_meshDistMarch_02.jpg" alt=""> <h2 id="14">Example: Quadrangulated data</h2><p>Get example quadrangulated mesh data</p><pre class="codeinput">n=4;
r=1;
[F,V]=quadSphere(n,r);
</pre><p>Compute distances on mesh</p><pre class="codeinput"><span class="comment">%Option set</span>
[~,indStart]=min(V(:,1)); <span class="comment">%Index of the start point</span>
optionStruct.toleranceLevel=0; <span class="comment">%Tolerance for convergence</span>
optionStruct.numSeeds=1; <span class="comment">%Number of seeds</span>
optionStruct.waitBarOn=0; <span class="comment">%Turn on/off waitbar</span>

<span class="comment">%Compute distances on mesh description</span>
d=meshDistMarch(F,V,indStart,optionStruct);
</pre><p>Visualization</p><pre class="codeinput">cFigure;
subplot(1,2,1);hold <span class="string">on</span>;
title(<span class="string">'Distances on a quad surface model'</span>,<span class="string">'fontSize'</span>,fontSize);
gpatch(F,V,<span class="string">'kw'</span>,d,1);
hp(1)=gpatch(F,V,<span class="string">'none'</span>,d,1,2);
hp(2)=plotV(V(indStart,:),<span class="string">'k.'</span>,<span class="string">'MarkerSize'</span>,markerSize);
legend(hp,{<span class="string">'Mesh distances'</span>,<span class="string">'Start point(s)'</span>},<span class="string">'Location'</span>,<span class="string">'SouthOutSide'</span>);
axisGeom;
colorbar;
camlight <span class="string">headlight</span>;

subplot(1,2,2);hold <span class="string">on</span>;
title(<span class="string">'Distances on a quad surface model'</span>,<span class="string">'fontSize'</span>,fontSize);
hp(1)=gpatch(F,V,d,<span class="string">'none'</span>,1);
hp(2)=plotV(V(indStart,:),<span class="string">'k.'</span>,<span class="string">'MarkerSize'</span>,markerSize);
legend(hp,{<span class="string">'Mesh distances'</span>,<span class="string">'Start point(s)'</span>},<span class="string">'Location'</span>,<span class="string">'SouthOutSide'</span>);
axisGeom;
camlight <span class="string">headlight</span>;
colorbar;
drawnow;
</pre><img width="100%" height="auto" vspace="5" hspace="5" src="HELP_meshDistMarch_03.jpg" alt=""> <h2 id="18">Example: Hexahedral mesh data</h2><p>Get example hexahedral mesh data</p><pre class="codeinput">cubeDimensions=[1 1 1];
cubeElementNumbers=[10 10 10];
outputStructType=2; <span class="comment">%A structure compatible with mesh view</span>
[meshStruct]=hexMeshBox(cubeDimensions,cubeElementNumbers,outputStructType);

<span class="comment">%Access elements, nodes, and faces from the structure</span>
HEX=meshStruct.elements; <span class="comment">%The elements</span>
F=meshStruct.faces; <span class="comment">%The faces</span>
V=meshStruct.nodes; <span class="comment">%The nodes (vertices)</span>

<span class="comment">%Get edges for mesh marching</span>
E=patchEdges(F); <span class="comment">%Mesh edges</span>
</pre><p>Compute distances on mesh</p><pre class="codeinput"><span class="comment">%Option set</span>
[~,indStart]=min(V(:,1)); <span class="comment">%Index of the start point</span>
optionStruct.toleranceLevel=0; <span class="comment">%Tolerance for convergence</span>
optionStruct.numSeeds=1; <span class="comment">%Number of seeds</span>
optionStruct.waitBarOn=0; <span class="comment">%Turn on/off waitbar</span>

<span class="comment">%Compute distances on mesh description</span>
d=meshDistMarch(E,V,indStart,optionStruct);
</pre><p>Plotting model boundary surfaces and a cut view</p><pre class="codeinput">cFigure; hold <span class="string">on</span>
title(<span class="string">'Distances on a hexahedral mesh'</span>,<span class="string">'FontSize'</span>,fontSize);
hp(1)=gpatch(E,V,<span class="string">'none'</span>,d,1,3);
hp(2)=plotV(V(indStart,:),<span class="string">'k.'</span>,<span class="string">'MarkerSize'</span>,markerSize);
legend(hp,{<span class="string">'Mesh distances'</span>,<span class="string">'Start point(s)'</span>},<span class="string">'Location'</span>,<span class="string">'SouthOutSide'</span>);
colorbar;
axisGeom(gca,fontSize);
drawnow;
</pre><img width="100%" height="auto" vspace="5" hspace="5" src="HELP_meshDistMarch_04.jpg" alt=""> <h2 id="22">Example: Tetrahedral mesh data</h2><p>Get example tetrahedral mesh data</p><pre class="codeinput">[TET,V]=hex2tet(HEX,V,[],2);
F=element2patch(TET,V); <span class="comment">%Element faces</span>

<span class="comment">%Get edges for mesh marching</span>
E=patchEdges(F); <span class="comment">%Mesh edges</span>
</pre><p>Compute distances on mesh</p><pre class="codeinput"><span class="comment">%Option set</span>
[~,indStart]=min(abs(V(:,1)-min(V(:,1)))+abs(V(:,2)-max(V(:,2)))+abs(V(:,3)-min(V(:,3)))); <span class="comment">%Index of the start point</span>
optionStruct.toleranceLevel=0; <span class="comment">%Tolerance for convergence</span>
optionStruct.numSeeds=1; <span class="comment">%Number of seeds</span>
optionStruct.waitBarOn=0; <span class="comment">%Turn on/off waitbar</span>

<span class="comment">%Compute distances on mesh description</span>
d=meshDistMarch(E,V,indStart,optionStruct);
</pre><p>Plotting model boundary surfaces and a cut view</p><pre class="codeinput">cFigure; hold <span class="string">on</span>
title(<span class="string">'Distances on a tetrahedral mesh'</span>,<span class="string">'FontSize'</span>,fontSize);
hp(1)=gpatch(E,V,<span class="string">'none'</span>,d,1,3);
hp(2)=plotV(V(indStart,:),<span class="string">'k.'</span>,<span class="string">'MarkerSize'</span>,markerSize);
legend(hp,{<span class="string">'Mesh distances'</span>,<span class="string">'Start point(s)'</span>},<span class="string">'Location'</span>,<span class="string">'SouthOutSide'</span>);
colorbar;
axisGeom(gca,fontSize);
drawnow;
</pre><img width="100%" height="auto" vspace="5" hspace="5" src="HELP_meshDistMarch_05.jpg" alt=""> <h2 id="26">Example: Mesh types effecting marching based distance computation</h2><p>In this example 3 mesh variations for a sphere are created. For each the start point is the point with the minimum x coordinate, i.e. a point on the far left of the plot. For each the true distance should be a smooth gradient with a maximum which equals pi. The marching algorithm uses the mesh to march and compute distances. One can imaging that straight paths (geodesically speaking) yeild the shortest distances. Hence zig-zag pattern (geodesically speaking) create false increased distances. This is not compensated for in this algorithm. Therefore the distance map depends on the mesh type and mesh connectivity. In the below example the regular quadrilateral mesh contains a straight path to the farthest point allong the equator. With mesh refinement the maximum distance would therefore converge on pi. However, other directions for the quadrilateral mesh produce zig-zag patterns causing distance to be altered. Hence the distance map departs from the smooth gradient allong the x-direction, one would expect. The triangulated mesh converted from the quadrilateral mesh contains both a straight path at the equator and also improved connectivity for other directions. The uniform geodesic triangulation contains the most smooth distance map.</p><p>Getting 3 different mesh types for a sphere.</p><pre class="codeinput">n=3;
r=1;
[F1,V1]=quadSphere(n,r);
[F2,V2]=quad2tri(F1,V1);
[F3,V3]=geoSphere(n,r);
</pre><p>Compute distances on mesh</p><pre class="codeinput"><span class="comment">% -&gt; Surface 1</span>
<span class="comment">%Option set</span>
[~,indStart1]=min(V1(:,1)); <span class="comment">%Index of the start point</span>
optionStruct.toleranceLevel=0; <span class="comment">%Tolerance for convergence</span>
optionStruct.numSeeds=1; <span class="comment">%Number of seeds</span>
optionStruct.waitBarOn=0; <span class="comment">%Turn on/off waitbar</span>

<span class="comment">%Compute distances on mesh description</span>
[d1,i1]=meshDistMarch(F1,V1,indStart1,optionStruct);

<span class="comment">% -&gt; Surface 2</span>
<span class="comment">%Option set</span>
[~,indStart2]=min(V2(:,1)); <span class="comment">%Index of the start point</span>
optionStruct.toleranceLevel=0; <span class="comment">%Tolerance for convergence</span>
optionStruct.numSeeds=1; <span class="comment">%Number of seeds</span>
optionStruct.waitBarOn=0; <span class="comment">%Turn on/off waitbar</span>

<span class="comment">%Compute distances on mesh description</span>
[d2,i2]=meshDistMarch(F2,V2,indStart2,optionStruct);

<span class="comment">% -&gt; Surface 3</span>
<span class="comment">%Option set</span>
[~,indStart3]=min(V3(:,1)); <span class="comment">%Index of the start point</span>
optionStruct.toleranceLevel=0; <span class="comment">%Tolerance for convergence</span>
optionStruct.numSeeds=1; <span class="comment">%Number of seeds</span>
optionStruct.waitBarOn=0; <span class="comment">%Turn on/off waitbar</span>

<span class="comment">%Compute distances on mesh description</span>
[d3,i3]=meshDistMarch(F3,V3,indStart3,optionStruct);
</pre><p>Visualization</p><pre class="codeinput">cFigure;
subplot(1,3,1);hold <span class="string">on</span>;
title(<span class="string">'Regular quad mesh'</span>,<span class="string">'fontSize'</span>,fontSize);
hp(1)=gpatch(F1,V1,d1,d1);
hp(2)=plotV(V1(indStart1,:),<span class="string">'k.'</span>,<span class="string">'MarkerSize'</span>,markerSize);
legend(hp,{<span class="string">'Mesh distances'</span>,<span class="string">'Start point(s)'</span>},<span class="string">'Location'</span>,<span class="string">'SouthOutSide'</span>);
axisGeom;
colorbar; caxis([0 pi]);
camlight <span class="string">headlight</span>;
view(2);

subplot(1,3,2);hold <span class="string">on</span>;
title(<span class="string">'Irregular quad mesh'</span>,<span class="string">'fontSize'</span>,fontSize);
hp(1)=gpatch(F2,V2,d2,d2);
hp(2)=plotV(V2(indStart2,:),<span class="string">'k.'</span>,<span class="string">'MarkerSize'</span>,markerSize);
legend(hp,{<span class="string">'Mesh distances'</span>,<span class="string">'Start point(s)'</span>},<span class="string">'Location'</span>,<span class="string">'SouthOutSide'</span>);
axisGeom;
colorbar; caxis([0 pi]);
camlight <span class="string">headlight</span>;
view(2);

subplot(1,3,3);hold <span class="string">on</span>;
title(<span class="string">'Geodesic triangulated mesh'</span>,<span class="string">'fontSize'</span>,fontSize);
hp(1)=gpatch(F3,V3,d3,d3);
hp(2)=plotV(V3(indStart3,:),<span class="string">'k.'</span>,<span class="string">'MarkerSize'</span>,markerSize);
legend(hp,{<span class="string">'Mesh distances'</span>,<span class="string">'Start point(s)'</span>},<span class="string">'Location'</span>,<span class="string">'SouthOutSide'</span>);
axisGeom;
colorbar; caxis([0 pi]);
camlight <span class="string">headlight</span>;
view(2);

drawnow;
</pre><img width="100%" height="auto" vspace="5" hspace="5" src="HELP_meshDistMarch_06.jpg" alt=""> <h2 id="30">Example: Using <tt>meshDistMarch</tt> for geodesic point sampling</h2><p>Get example triangulated mesh data</p><pre class="codeinput">[F,V]=graphicsModels(7);
</pre><p>Compute distances on mesh</p><pre class="codeinput">numSeeds=250;

<span class="comment">%Option set</span>
[~,indStart]=min(V(:,1)); <span class="comment">%Index of the start point</span>
optionStruct.toleranceLevel=0; <span class="comment">%Tolerance for convergence</span>
optionStruct.numSeeds=numSeeds; <span class="comment">%Number of seeds</span>
optionStruct.waitBarOn=1; <span class="comment">%Turn on/off waitbar</span>

<span class="comment">%Use weigths based on z-direction</span>
<span class="comment">% W=V(:,3);</span>
<span class="comment">% W=W-min(W);</span>
<span class="comment">% W=W./max(W);</span>
<span class="comment">% W=(W*9)+1;</span>
<span class="comment">% optionStruct.W=W;</span>

<span class="comment">%Compute distances on mesh description</span>
[d,seedIndex]=meshDistMarch(F,V,indStart,optionStruct);
[indSeeds,~,ind2]=unique(seedIndex);
</pre><p>Visualization</p><pre class="codeinput">cFigure;
subplot(1,2,1); hold <span class="string">on</span>;
title(<span class="string">'Distances on a triangulated surface model'</span>,<span class="string">'fontSize'</span>,fontSize);
hp(1)=gpatch(F,V,d,<span class="string">'none'</span>,1); hp(1).FaceColor=<span class="string">'Interp'</span>;
hp(2)=plotV(V(indSeeds,:),<span class="string">'k.'</span>,<span class="string">'MarkerSize'</span>,markerSize);
legend(hp,{<span class="string">'Mesh distances'</span>,<span class="string">'Seed point(s)'</span>},<span class="string">'Location'</span>,<span class="string">'SouthOutSide'</span>);
axisGeom;
camlight <span class="string">headlight</span>;
colormap(gca,cMapDist); colorbar;

subplot(1,2,2); hold <span class="string">on</span>;
title(<span class="string">'Seed indices'</span>,<span class="string">'fontSize'</span>,fontSize);
hp(1)=gpatch(F,V,<span class="string">'kw'</span>,ind2,1);
hp(2)=plotV(V(indSeeds,:),<span class="string">'k.'</span>,<span class="string">'MarkerSize'</span>,markerSize);
legend(hp,{<span class="string">'Mesh distances'</span>,<span class="string">'Seed point(s)'</span>},<span class="string">'Location'</span>,<span class="string">'SouthOutSide'</span>);
axisGeom;
camlight <span class="string">headlight</span>;
colormap(gca,cMapIndices); <span class="comment">%icolorbar;</span>
drawnow;
</pre><img width="100%" height="auto" vspace="5" hspace="5" src="HELP_meshDistMarch_07.jpg" alt=""> <h2 id="34">Example: Using <tt>meshDistMarch</tt> for geodesic surface resampling</h2><p>See also: <tt>remeshTriSurfDistMap</tt></p><pre class="codeinput">[Fd,Vd,indSeed]=seedIndex2triangulation(F,V,seedIndex);
</pre><p>Visualization</p><pre class="codeinput">cFigure;
subplot(1,2,1); hold <span class="string">on</span>;
title(<span class="string">'Distances on a triangulated surface model'</span>,<span class="string">'fontSize'</span>,fontSize);
hp(1)=gpatch(F,V,d,<span class="string">'none'</span>,1); hp(1).FaceColor=<span class="string">'Interp'</span>;
hp(2)=plotV(V(indSeeds,:),<span class="string">'k.'</span>,<span class="string">'MarkerSize'</span>,markerSize);
legend(hp,{<span class="string">'Mesh distances'</span>,<span class="string">'Seed point(s)'</span>},<span class="string">'Location'</span>,<span class="string">'SouthOutSide'</span>);
axisGeom;
camlight <span class="string">headlight</span>;
colormap(gca,cMapDist); colorbar;

subplot(1,2,2); hold <span class="string">on</span>;
title(<span class="string">'Resampled surface model'</span>,<span class="string">'fontSize'</span>,fontSize);
plotV(V(indSeed,:),<span class="string">'k.'</span>,<span class="string">'MarkerSize'</span>,50);
hp(1)=gpatch(F,V,<span class="string">'kw'</span>,<span class="string">'none'</span>,0.5);
hp(2)=gpatch(Fd,Vd,<span class="string">'gw'</span>,<span class="string">'k'</span>,1,2);
legend(hp,{<span class="string">'Original mesh'</span>,<span class="string">'Resampled mesh'</span>},<span class="string">'Location'</span>,<span class="string">'SouthOutSide'</span>);

axisGeom;
camlight <span class="string">headlight</span>;
drawnow;
</pre><img width="100%" height="auto" vspace="5" hspace="5" src="HELP_meshDistMarch_08.jpg" alt=""> <h2 id="36">Example: Using unit edge lengths</h2><p>Forcing unit edge lenghts means each edge is considered equally long i.e. a length of 1. Hence when used in combination with resampling, this causes the algorithm to resample dense regions in a dense fashion and coarse regions in a coarse fashion. Therefore using optionStruct.unitEdgeOn=1; one can force the resampling to have similar degrees of relative density differences. In the example below a dinosaur mesh with a fine mesh at the limbs and a coarse mesh on the main body is resampled using unit edge lengths. The output can be seen to remain refined at the limbs.</p><p>Get example triangulated mesh data</p><pre class="codeinput">[F,V]=graphicsModels(4);
[F,V]=subtri(F,V,2);
</pre><p>Compute distances on mesh</p><pre class="codeinput"><span class="comment">%Option set</span>
[~,indStart]=min(V(:,1)); <span class="comment">%Index of the start point</span>
optionStruct.toleranceLevel=0; <span class="comment">%Tolerance for convergence</span>
optionStruct.numSeeds=1000; <span class="comment">%Number of seeds</span>
optionStruct.waitBarOn=1; <span class="comment">%Turn on/off waitbar</span>
optionStruct.unitEdgeOn=1;

<span class="comment">%Compute distances on mesh description</span>
[d,seedIndex]=meshDistMarch(F,V,indStart,optionStruct);
[indSeeds,~,ind2]=unique(seedIndex);

<span class="comment">%Compute resampled surface</span>
[Fd,Vd,indSeed]=seedIndex2triangulation(F,V,seedIndex);
</pre><p>Visualization</p><pre class="codeinput">cFigure;
subplot(1,2,1); hold <span class="string">on</span>;
title(<span class="string">'Distances on a triangulated surface model'</span>,<span class="string">'fontSize'</span>,fontSize);
hp(1)=gpatch(F,V,d,<span class="string">'none'</span>,1); hp(1).FaceColor=<span class="string">'Interp'</span>;
hp(2)=plotV(V(indSeeds,:),<span class="string">'k.'</span>,<span class="string">'MarkerSize'</span>,25);
legend(hp,{<span class="string">'Mesh distances'</span>,<span class="string">'Seed point(s)'</span>},<span class="string">'Location'</span>,<span class="string">'SouthOutSide'</span>);
axisGeom;
camlight <span class="string">headlight</span>;
colormap(gca,cMapDist); colorbar;

subplot(1,2,2); hold <span class="string">on</span>;
title(<span class="string">'Resampled surface model'</span>,<span class="string">'fontSize'</span>,fontSize);
plotV(V(indSeed,:),<span class="string">'k.'</span>,<span class="string">'MarkerSize'</span>,25);
hp(1)=gpatch(F,V,<span class="string">'kw'</span>,<span class="string">'none'</span>,0.5);
hp(2)=gpatch(Fd,Vd,<span class="string">'gw'</span>,<span class="string">'k'</span>,1,2);
legend(hp,{<span class="string">'Original mesh'</span>,<span class="string">'Resampled mesh'</span>},<span class="string">'Location'</span>,<span class="string">'SouthOutSide'</span>);

axisGeom;
camlight <span class="string">headlight</span>;
drawnow;
</pre><img width="100%" height="auto" vspace="5" hspace="5" src="HELP_meshDistMarch_09.jpg" alt=""> <p><img vspace="5" hspace="5" src="gibbVerySmall.gif" alt=""> </p><p><i><b>GIBBON</b></i> <a href="www.gibboncode.org">www.gibboncode.org</a></p><p><i>Kevin Mattheus Moerman</i>, <a href="gibbon.toolbox@gmail.com">gibbon.toolbox@gmail.com</a></p><p><i><b>GIBBON footer text</b></i></p><p>License: <a href="https://github.com/gibbonCode/GIBBON/blob/master/LICENSE">https://github.com/gibbonCode/GIBBON/blob/master/LICENSE</a></p><p>GIBBON: The Geometry and Image-based Bioengineering add-On. A toolbox for image segmentation, image-based modeling, meshing, and finite element analysis.</p><p>Copyright (C) 2019  Kevin Mattheus Moerman</p><p>This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.</p><p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.</p><p>You should have received a copy of the GNU General Public License along with this program.  If not, see <a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>.</p><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2019a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% meshDistMarch
% Below is a demonstration of the features of the |meshDistMarch| function

%%
clear; close all; clc;

%% Syntax
% |[d,seedIndex]=meshDistMarch(F,V,indStart,optionStruct);|

%% Description
% The meshDistMarch function can be used to compute distances on meshes.
% The distances can be used for points sampling on the mesh or for
% remeshing. 
% The function can operate on edge descriptions or face descriptions.
% Therefore for volumetric meshes (e.g. consisting of tetrahedra or
% hexahedra) appropriate face or edge data should be computed first to
% formulate the input. 
%
% Input:
% E: the edges or faces for the mesh. E.g. an nx2 edge matrix or an nxm
% face matrix (n faces, m corners per face)
% V: the vertices for the mesh
% indStart: indices for one or more points to compute distances from
% optionStruct.toleranceLevel : The tolerance level for convergence. 0 is
% the default. 
% optionStruct.numSeeds: Defines the number of seeds to generate on the mesh. Default is equal to startInd.
% optionStruct.waitBarOn=0; %Turn on/off waitbar
% optionStruct.unitEdgeOn=1; %Turn on/off the use of unit edge lengths
% 
% Output: 
% d: distances (from the start/seed points) on the mesh vertices 
% seedIndex: nearest seed (or start) point indices for each vertex, forming
% a quasi-Voronoi tesselation.
% If the second output is not requested the performance is enhanced. 

%% Examples

%%
% Plot settings
cMapDist=flipud(igviridis(250));
[cMapIndices,scrambleIndices]=scramble(viridis(250),1); %Colormap

faceAlpha1=1;
faceAlpha2=0.65;
fontSize=25; 
markerSize=50;

%% Example: Edge or graph data 

%%
% Create branching example. E defines edges and V is a vertex array

n=75;
x=linspace(0,0.9*pi,n);
y=sin(x);
V=[x(:) y(:) zeros(size(x(:)))];
V=evenlySampleCurve(V,n,'pchip',0);
x=V(:,1);
y=V(:,2);
dV=vecnormalize(diff(V,1,1));
VdV=V(1:1:end-1,:);
placePoints=1:3:n-1;
E=[(1:1:n-1)' (2:1:n)'];
numSteps=numel(placePoints);
l=linspace(0.75,0.25,numSteps);
a=linspace(0.25*pi,0.25*pi,numSteps);
for q=1:1:numSteps        
    R=euler2DCM([0 0 a(q)]);
    vr1=dV(placePoints(q),:)*R.*l(q);
    vr2=dV(placePoints(q),:)*R'.*l(q);        
    Vb=linspacen([x(placePoints(q)) y(placePoints(q)) 0],vr1+[x(placePoints(q)) y(placePoints(q)) 0],n)';
    Eb=[(1:1:n-1)' (2:1:n)'];    
    E=[E; Eb+size(V,1)];
    V=[V; Vb];    
    Vb=linspacen([x(placePoints(q)) y(placePoints(q)) 0],vr2+[x(placePoints(q)) y(placePoints(q)) 0],n)';
    Eb=[(1:1:n-1)' (2:1:n)'];
    E=[E; Eb+size(V,1)];
    V=[V; Vb];
end
E=[E;E+size(V,1);];
V2=V;
V2(:,2)=-V2(:,2);
V2(:,1)=-V2(:,1);
V=[V;V2];
E=[E;E+size(V,1);];
V2=V;
V2(:,2)=-V2(:,2);
V=[V;V2];
[E,V]=mergeVertices(E,V);

%%
% Compute distances on mesh

%Option set
indStart=1; %Index of the start point
optionStruct.toleranceLevel=0; %Tolerance for convergence
optionStruct.numSeeds=1; %Number of seeds
optionStruct.waitBarOn=0; %Turn on/off waitbar

%Compute distances on mesh description
d=meshDistMarch(E,V,indStart,optionStruct);

%%
% Visualization

cFigure; hold on;
title('Distances on an edge / graph model','fontSize',fontSize);
hp(1)=gpatch(E,V,'none',d,1,4);
hp(2)=plotV(V(indStart,:),'k.','MarkerSize',markerSize);
legend(hp,{'Mesh distances','Start point(s)'},'Location','SouthOutSide');
axisGeom;
view(2);
colorbar;
drawnow; 

%% Example: Triangulated data 

%%
% Get example triangulated mesh data
[F,V]=stanford_bunny;%graphicsModels(1);

%%
% Compute distances on mesh

%Option set
[~,indStart]=min(V(:,1)); %Index of the start point
optionStruct.toleranceLevel=0; %Tolerance for convergence
optionStruct.numSeeds=1; %Number of seeds
optionStruct.waitBarOn=0; %Turn on/off waitbar

%Compute distances on mesh description
d=meshDistMarch(F,V,indStart,optionStruct);

%%
% Visualization

cFigure; 
subplot(1,2,1);hold on;
title('Distances on a triangulated surface model','fontSize',fontSize);
gpatch(F,V,'kw',d,1);
hp(1)=gpatch(F,V,'none',d,1,2);
hp(2)=plotV(V(indStart,:),'k.','MarkerSize',markerSize);
legend(hp,{'Mesh distances','Start point(s)'},'Location','SouthOutSide');
axisGeom;
colorbar;
camlight headlight;

subplot(1,2,2);hold on;
title('Distances on a triangulated surface model','fontSize',fontSize);
hp(1)=gpatch(F,V,d,'none',1);
hp(2)=plotV(V(indStart,:),'k.','MarkerSize',markerSize);
legend(hp,{'Mesh distances','Start point(s)'},'Location','SouthOutSide');
axisGeom;
camlight headlight;
colorbar;
drawnow; 

%% Example: Quadrangulated data 

%%
% Get example quadrangulated mesh data
n=4;
r=1;
[F,V]=quadSphere(n,r);

%%
% Compute distances on mesh

%Option set
[~,indStart]=min(V(:,1)); %Index of the start point
optionStruct.toleranceLevel=0; %Tolerance for convergence
optionStruct.numSeeds=1; %Number of seeds
optionStruct.waitBarOn=0; %Turn on/off waitbar

%Compute distances on mesh description
d=meshDistMarch(F,V,indStart,optionStruct);

%%
% Visualization

cFigure; 
subplot(1,2,1);hold on;
title('Distances on a quad surface model','fontSize',fontSize);
gpatch(F,V,'kw',d,1);
hp(1)=gpatch(F,V,'none',d,1,2);
hp(2)=plotV(V(indStart,:),'k.','MarkerSize',markerSize);
legend(hp,{'Mesh distances','Start point(s)'},'Location','SouthOutSide');
axisGeom;
colorbar;
camlight headlight;

subplot(1,2,2);hold on;
title('Distances on a quad surface model','fontSize',fontSize);
hp(1)=gpatch(F,V,d,'none',1);
hp(2)=plotV(V(indStart,:),'k.','MarkerSize',markerSize);
legend(hp,{'Mesh distances','Start point(s)'},'Location','SouthOutSide');
axisGeom;
camlight headlight;
colorbar;
drawnow; 

%% Example: Hexahedral mesh data 

%%
% Get example hexahedral mesh data
cubeDimensions=[1 1 1];
cubeElementNumbers=[10 10 10];
outputStructType=2; %A structure compatible with mesh view
[meshStruct]=hexMeshBox(cubeDimensions,cubeElementNumbers,outputStructType);

%Access elements, nodes, and faces from the structure
HEX=meshStruct.elements; %The elements
F=meshStruct.faces; %The faces
V=meshStruct.nodes; %The nodes (vertices)

%Get edges for mesh marching
E=patchEdges(F); %Mesh edges

%%
% Compute distances on mesh

%Option set
[~,indStart]=min(V(:,1)); %Index of the start point
optionStruct.toleranceLevel=0; %Tolerance for convergence
optionStruct.numSeeds=1; %Number of seeds
optionStruct.waitBarOn=0; %Turn on/off waitbar

%Compute distances on mesh description
d=meshDistMarch(E,V,indStart,optionStruct);

%% 
% Plotting model boundary surfaces and a cut view

cFigure; hold on
title('Distances on a hexahedral mesh','FontSize',fontSize);
hp(1)=gpatch(E,V,'none',d,1,3); 
hp(2)=plotV(V(indStart,:),'k.','MarkerSize',markerSize);
legend(hp,{'Mesh distances','Start point(s)'},'Location','SouthOutSide');
colorbar;
axisGeom(gca,fontSize);
drawnow;

%% Example: Tetrahedral mesh data 

%%
% Get example tetrahedral mesh data
[TET,V]=hex2tet(HEX,V,[],2);
F=element2patch(TET,V); %Element faces

%Get edges for mesh marching
E=patchEdges(F); %Mesh edges

%%
% Compute distances on mesh

%Option set
[~,indStart]=min(abs(V(:,1)-min(V(:,1)))+abs(V(:,2)-max(V(:,2)))+abs(V(:,3)-min(V(:,3)))); %Index of the start point
optionStruct.toleranceLevel=0; %Tolerance for convergence
optionStruct.numSeeds=1; %Number of seeds
optionStruct.waitBarOn=0; %Turn on/off waitbar

%Compute distances on mesh description
d=meshDistMarch(E,V,indStart,optionStruct);

%% 
% Plotting model boundary surfaces and a cut view

cFigure; hold on
title('Distances on a tetrahedral mesh','FontSize',fontSize);
hp(1)=gpatch(E,V,'none',d,1,3); 
hp(2)=plotV(V(indStart,:),'k.','MarkerSize',markerSize);
legend(hp,{'Mesh distances','Start point(s)'},'Location','SouthOutSide');
colorbar;
axisGeom(gca,fontSize);
drawnow;

%% Example: Mesh types effecting marching based distance computation
% In this example 3 mesh variations for a sphere are created. For each the
% start point is the point with the minimum x coordinate, i.e. a point on
% the far left of the plot. For each the true distance should be a smooth
% gradient with a maximum which equals pi. 
% The marching algorithm uses the mesh to march and compute distances. One
% can imaging that straight paths (geodesically speaking) yeild the
% shortest distances. Hence zig-zag pattern (geodesically speaking) create
% false increased distances. This is not compensated for in this algorithm.
% Therefore the distance map depends on the mesh type and mesh
% connectivity. In the below example the regular quadrilateral mesh
% contains a straight path to the farthest point allong the equator. With
% mesh refinement the maximum distance would therefore converge on pi.
% However, other directions for the quadrilateral mesh produce zig-zag
% patterns causing distance to be altered. Hence the distance map departs
% from the smooth gradient allong the x-direction, one would expect. The
% triangulated mesh converted from the quadrilateral mesh contains both a
% straight path at the equator and also improved connectivity for other
% directions. The uniform geodesic triangulation contains the most smooth
% distance map. 

%%
% Getting 3 different mesh types for a sphere. 

n=3;
r=1;
[F1,V1]=quadSphere(n,r);
[F2,V2]=quad2tri(F1,V1);
[F3,V3]=geoSphere(n,r);

%%
% Compute distances on mesh

% -> Surface 1
%Option set
[~,indStart1]=min(V1(:,1)); %Index of the start point
optionStruct.toleranceLevel=0; %Tolerance for convergence
optionStruct.numSeeds=1; %Number of seeds
optionStruct.waitBarOn=0; %Turn on/off waitbar

%Compute distances on mesh description
[d1,i1]=meshDistMarch(F1,V1,indStart1,optionStruct);

% -> Surface 2
%Option set
[~,indStart2]=min(V2(:,1)); %Index of the start point
optionStruct.toleranceLevel=0; %Tolerance for convergence
optionStruct.numSeeds=1; %Number of seeds
optionStruct.waitBarOn=0; %Turn on/off waitbar

%Compute distances on mesh description
[d2,i2]=meshDistMarch(F2,V2,indStart2,optionStruct);

% -> Surface 3
%Option set
[~,indStart3]=min(V3(:,1)); %Index of the start point
optionStruct.toleranceLevel=0; %Tolerance for convergence
optionStruct.numSeeds=1; %Number of seeds
optionStruct.waitBarOn=0; %Turn on/off waitbar

%Compute distances on mesh description
[d3,i3]=meshDistMarch(F3,V3,indStart3,optionStruct);

%%
% Visualization

cFigure; 
subplot(1,3,1);hold on;
title('Regular quad mesh','fontSize',fontSize);
hp(1)=gpatch(F1,V1,d1,d1);
hp(2)=plotV(V1(indStart1,:),'k.','MarkerSize',markerSize);
legend(hp,{'Mesh distances','Start point(s)'},'Location','SouthOutSide');
axisGeom;
colorbar; caxis([0 pi]);
camlight headlight;
view(2); 

subplot(1,3,2);hold on;
title('Irregular quad mesh','fontSize',fontSize);
hp(1)=gpatch(F2,V2,d2,d2);
hp(2)=plotV(V2(indStart2,:),'k.','MarkerSize',markerSize);
legend(hp,{'Mesh distances','Start point(s)'},'Location','SouthOutSide');
axisGeom;
colorbar; caxis([0 pi]);
camlight headlight;
view(2); 

subplot(1,3,3);hold on;
title('Geodesic triangulated mesh','fontSize',fontSize);
hp(1)=gpatch(F3,V3,d3,d3);
hp(2)=plotV(V3(indStart3,:),'k.','MarkerSize',markerSize);
legend(hp,{'Mesh distances','Start point(s)'},'Location','SouthOutSide');
axisGeom;
colorbar; caxis([0 pi]);
camlight headlight;
view(2); 

drawnow; 

%% Example: Using |meshDistMarch| for geodesic point sampling

%%
% Get example triangulated mesh data
[F,V]=graphicsModels(7);

%%
% Compute distances on mesh

numSeeds=250;

%Option set
[~,indStart]=min(V(:,1)); %Index of the start point
optionStruct.toleranceLevel=0; %Tolerance for convergence
optionStruct.numSeeds=numSeeds; %Number of seeds
optionStruct.waitBarOn=1; %Turn on/off waitbar

%Use weigths based on z-direction
% W=V(:,3);
% W=W-min(W);
% W=W./max(W);
% W=(W*9)+1;
% optionStruct.W=W;

%Compute distances on mesh description
[d,seedIndex]=meshDistMarch(F,V,indStart,optionStruct);
[indSeeds,~,ind2]=unique(seedIndex);

%%
% Visualization

cFigure; 
subplot(1,2,1); hold on;
title('Distances on a triangulated surface model','fontSize',fontSize);
hp(1)=gpatch(F,V,d,'none',1); hp(1).FaceColor='Interp';
hp(2)=plotV(V(indSeeds,:),'k.','MarkerSize',markerSize);
legend(hp,{'Mesh distances','Seed point(s)'},'Location','SouthOutSide');
axisGeom;
camlight headlight;
colormap(gca,cMapDist); colorbar;

subplot(1,2,2); hold on;
title('Seed indices','fontSize',fontSize);
hp(1)=gpatch(F,V,'kw',ind2,1); 
hp(2)=plotV(V(indSeeds,:),'k.','MarkerSize',markerSize);
legend(hp,{'Mesh distances','Seed point(s)'},'Location','SouthOutSide');
axisGeom;
camlight headlight;
colormap(gca,cMapIndices); %icolorbar;
drawnow; 

%% Example: Using |meshDistMarch| for geodesic surface resampling
% See also: |remeshTriSurfDistMap|

[Fd,Vd,indSeed]=seedIndex2triangulation(F,V,seedIndex);

%%
% Visualization

cFigure; 
subplot(1,2,1); hold on;
title('Distances on a triangulated surface model','fontSize',fontSize);
hp(1)=gpatch(F,V,d,'none',1); hp(1).FaceColor='Interp';
hp(2)=plotV(V(indSeeds,:),'k.','MarkerSize',markerSize);
legend(hp,{'Mesh distances','Seed point(s)'},'Location','SouthOutSide');
axisGeom;
camlight headlight;
colormap(gca,cMapDist); colorbar;

subplot(1,2,2); hold on;
title('Resampled surface model','fontSize',fontSize);
plotV(V(indSeed,:),'k.','MarkerSize',50);
hp(1)=gpatch(F,V,'kw','none',0.5);
hp(2)=gpatch(Fd,Vd,'gw','k',1,2);
legend(hp,{'Original mesh','Resampled mesh'},'Location','SouthOutSide');

axisGeom;
camlight headlight;
drawnow;

%% Example: Using unit edge lengths
% Forcing unit edge lenghts means each edge is considered equally long i.e.
% a length of 1. Hence when used in combination with resampling, this
% causes the algorithm to resample dense regions in a dense fashion and
% coarse regions in a coarse fashion. Therefore using
% optionStruct.unitEdgeOn=1; one can force the resampling to have similar
% degrees of relative density differences. In the example below a dinosaur
% mesh with a fine mesh at the limbs and a coarse mesh on the main body is
% resampled using unit edge lengths. The output can be seen to remain
% refined at the limbs.  

%%
% Get example triangulated mesh data
[F,V]=graphicsModels(4);
[F,V]=subtri(F,V,2);

%%
% Compute distances on mesh

%Option set
[~,indStart]=min(V(:,1)); %Index of the start point
optionStruct.toleranceLevel=0; %Tolerance for convergence
optionStruct.numSeeds=1000; %Number of seeds
optionStruct.waitBarOn=1; %Turn on/off waitbar
optionStruct.unitEdgeOn=1;

%Compute distances on mesh description
[d,seedIndex]=meshDistMarch(F,V,indStart,optionStruct);
[indSeeds,~,ind2]=unique(seedIndex);

%Compute resampled surface
[Fd,Vd,indSeed]=seedIndex2triangulation(F,V,seedIndex);

%%
% Visualization

cFigure; 
subplot(1,2,1); hold on;
title('Distances on a triangulated surface model','fontSize',fontSize);
hp(1)=gpatch(F,V,d,'none',1); hp(1).FaceColor='Interp';
hp(2)=plotV(V(indSeeds,:),'k.','MarkerSize',25);
legend(hp,{'Mesh distances','Seed point(s)'},'Location','SouthOutSide');
axisGeom;
camlight headlight;
colormap(gca,cMapDist); colorbar;

subplot(1,2,2); hold on;
title('Resampled surface model','fontSize',fontSize);
plotV(V(indSeed,:),'k.','MarkerSize',25);
hp(1)=gpatch(F,V,'kw','none',0.5);
hp(2)=gpatch(Fd,Vd,'gw','k',1,2);
legend(hp,{'Original mesh','Resampled mesh'},'Location','SouthOutSide');

axisGeom;
camlight headlight;
drawnow;

%% 
%
% <<gibbVerySmall.gif>>
% 
% _*GIBBON*_ 
% <www.gibboncode.org>
% 
% _Kevin Mattheus Moerman_, <gibbon.toolbox@gmail.com>
 
%% 
% _*GIBBON footer text*_ 
% 
% License: <https://github.com/gibbonCode/GIBBON/blob/master/LICENSE>
% 
% GIBBON: The Geometry and Image-based Bioengineering add-On. A toolbox for
% image segmentation, image-based modeling, meshing, and finite element
% analysis.
% 
% Copyright (C) 2019  Kevin Mattheus Moerman
% 
% This program is free software: you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation, either version 3 of the License, or
% (at your option) any later version.
% 
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License
% along with this program.  If not, see <http://www.gnu.org/licenses/>.

##### SOURCE END #####
--></body></html>
