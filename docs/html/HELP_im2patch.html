
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>im2patch</title><meta name="generator" content="MATLAB 9.8"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2020-05-11"><meta name="DC.source" content="HELP_im2patch.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>im2patch</h1><!--introduction--><p>Below is a demonstration of the features of the <tt>im2patch</tt> function</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#2">Syntax</a></li><li><a href="#3">Description</a></li><li><a href="#4">Examples</a></li><li><a href="#6">Example: Introduction to using <tt>im2patch</tt> for voxel plotting</a></li><li><a href="#13">Example: Introduction to using <tt>im2patch</tt> for slice plotting</a></li><li><a href="#15">Example: Comparison to standard MATLAB <tt>imagesc</tt> function and the patch type MATLAB functions <tt>slice</tt> and <tt>pcolor</tt></a></li><li><a href="#17">Example: Creating and plotting combined voxel and slice patch data</a></li><li><a href="#20">Example: Shrinking patch data through combination with <tt>scalePatch</tt> function</a></li><li><a href="#22">Example: Medical image data and coordinate manipulation due to voxel size</a></li><li><a href="#26">Example: Combining colormap and RGB driven patch colours</a></li></ul></div><pre class="codeinput">clear; close <span class="string">all</span>; clc;
</pre><h2 id="2">Syntax</h2><p><tt>[F,V,C]=im2patch(M,IND,ptype);</tt></p><h2 id="3">Description</h2><p>This function generates patch data for 3D images. The patch data is only generated for the voxels specified by the indices (logic or linear indices). The patch data is created according to the patch type desired (e.g. voxel type of slice type).</p><h2 id="4">Examples</h2><p>Plot settings</p><pre class="codeinput">cMap=parula(250);
faceAlpha1=1;
faceAlpha2=0.5;
edgeColor1=<span class="string">'none'</span>;
edgeColor2=<span class="string">'none'</span>;
fontSize=15;
</pre><h2 id="6">Example: Introduction to using <tt>im2patch</tt> for voxel plotting</h2><p>The voxel for which patch data is to be specified can be defined by supplying linear indices or a logic array.</p><pre class="codeinput"><span class="comment">% Simulating an image</span>
M=rand(3,5,7);
<span class="comment">% Example supplying linear indices, here all voxels</span>
indPatch=1:numel(M);
</pre><p>Creating patch data for voxel display</p><pre class="codeinput">[F,V,C]=im2patch(M,indPatch,<span class="string">'v'</span>);

cFigure;
title(<span class="string">'patch type: v'</span>);
xlabel(<span class="string">'J - columns'</span>);ylabel(<span class="string">'I - rows'</span>); zlabel(<span class="string">'K - slices'</span>); hold <span class="string">on</span>;
gpatch(F,V,C,<span class="string">'k'</span>,faceAlpha2);
colormap(cMap); caxis([min(M(:)) max(M(:))]); colorbar;
axisGeom(gca,fontSize); camlight <span class="string">headlight</span>;
drawnow;
</pre><img width="100%" height="auto" vspace="5" hspace="5" src="HELP_im2patch_01.jpg" alt=""> <p>Study the size of the face and vertex arrays to confirm that the patch type <tt>'v'</tt> creates vertices and faces for each voxel. Shared vertices and faces are not removed. This option requires the most memory.</p><pre class="codeinput">disp(num2str(size(F)));
disp(num2str(size(V)));
</pre><pre class="codeoutput">630    4
192    3
</pre><p>Creating patch data for voxel display with shared vertices and faces removed</p><pre class="codeinput">[F,V,C]=im2patch(M,indPatch,<span class="string">'vu'</span>);

cFigure;
title(<span class="string">'patch type: vu'</span>);
xlabel(<span class="string">'J - columns'</span>);ylabel(<span class="string">'I - rows'</span>); zlabel(<span class="string">'K - slices'</span>); hold <span class="string">on</span>;
gpatch(F,V,C,<span class="string">'k'</span>,faceAlpha2);
colormap(cMap); caxis([min(M(:)) max(M(:))]); colorbar;
axisGeom(gca,fontSize); camlight <span class="string">headlight</span>;
drawnow;
</pre><img width="100%" height="auto" vspace="5" hspace="5" src="HELP_im2patch_02.jpg" alt=""> <p>Study the size of the face and vertex arrays to confirm that the patch type <tt>'vu'</tt> ensures that shared faces and vertices are not shared. Each vertex and face is therefore unique. This saves memory with respect to using the <tt>'v'</tt> patch type for voxel display. The figures look identical except that shared faces may appear less dark when transparency is on since now one one face is used. Color information is shared too (averaged).</p><pre class="codeinput">disp(num2str(size(F)));
disp(num2str(size(V)));
</pre><pre class="codeoutput">386    4
192    3
</pre><p>Creating patch data for voxel display with only non-shared faces and vertices</p><pre class="codeinput">[F,V,C]=im2patch(M,indPatch,<span class="string">'vb'</span>);

cFigure;
title(<span class="string">'patch type: vb'</span>);
xlabel(<span class="string">'J - columns'</span>);ylabel(<span class="string">'I - rows'</span>); zlabel(<span class="string">'K - slices'</span>); hold <span class="string">on</span>;
gpatch(F,V,C,<span class="string">'k'</span>,faceAlpha2);
colormap(cMap); caxis([min(M(:)) max(M(:))]); colorbar;
axisGeom(gca,fontSize); camlight <span class="string">headlight</span>;
drawnow;
</pre><img width="100%" height="auto" vspace="5" hspace="5" src="HELP_im2patch_03.jpg" alt=""> <p>Study the size of the face and vertex arrays to confirm that the patch type <tt>'vb'</tt> helps to plot only non-shared vertices and faces. In the case of an enclosed shape filled with voxels thus only the boundary faces are displayed. This path type appears no different than the other is transparency is not on however it is much lighter on memory than the above path types.</p><pre class="codeinput">disp(num2str(size(F)));
disp(num2str(size(V)));
</pre><pre class="codeoutput">142    4
144    3
</pre><h2 id="13">Example: Introduction to using <tt>im2patch</tt> for slice plotting</h2><pre class="codeinput">cFigure;
title(<span class="string">'patch type: si, sj, sk'</span>);
xlabel(<span class="string">'J - columns'</span>);ylabel(<span class="string">'I - rows'</span>); zlabel(<span class="string">'K - slices'</span>); hold <span class="string">on</span>;

<span class="comment">%Setting up indices for I direction slices</span>
S=round(size(M,1)./2); <span class="comment">%Selection of middle slice</span>
L_plot=false(size(M)); L_plot(S,:,:)=1;
indPatch=find(L_plot);
[F,V,C]=im2patch(M,indPatch,<span class="string">'si'</span>); <span class="comment">%Creating patch data for y mid-voxel slices</span>
gpatch(F,V,C);

<span class="comment">%Setting up indices for J direction slices</span>
S=round(size(M,2)./2); <span class="comment">%Selection of middle slice</span>
L_plot=false(size(M)); L_plot(:,S,:)=1;
indPatch=find(L_plot);
[F,V,C]=im2patch(M,indPatch,<span class="string">'sj'</span>); <span class="comment">%Creating patch data for x mid-voxel slices</span>
gpatch(F,V,C);

<span class="comment">%Setting up indices for Z direction slices</span>
S=round(size(M,3)./2); <span class="comment">%Selection of middle slice</span>
L_plot=false(size(M)); L_plot(:,:,S)=1;
indPatch=find(L_plot);
[F,V,C]=im2patch(M,indPatch,<span class="string">'sk'</span>); <span class="comment">%Creating patch data for z mid-voxel slices</span>
gpatch(F,V,C);

colormap(cMap); caxis([min(M(:)) max(M(:))]); colorbar;
axisGeom(gca,fontSize); camlight <span class="string">headlight</span>;

drawnow;
</pre><img width="100%" height="auto" vspace="5" hspace="5" src="HELP_im2patch_04.jpg" alt=""> <p>The path type s*u are simular to s* but use shared vertices</p><h2 id="15">Example: Comparison to standard MATLAB <tt>imagesc</tt> function and the patch type MATLAB functions <tt>slice</tt> and <tt>pcolor</tt></h2><p>The comparison is what motivates the choice of coordinate system for im2patch i.e. that it is meant to aid in the visualization of image data as is expected of image data.</p><pre class="codeinput">cFigure;
subplot(2,2,1);
title(<span class="string">'MATLAB imagesc function'</span>);
xlabel(<span class="string">'J - columns'</span>);ylabel(<span class="string">'I - rows'</span>); zlabel(<span class="string">'K - slices'</span>); hold <span class="string">on</span>;
imagesc(M(:,:,S));
colormap(cMap); caxis([min(M(:)) max(M(:))]);
axisGeom(gca,fontSize); view(2);

subplot(2,2,2);
title(<span class="string">'MATLAB slice function'</span>);
xlabel(<span class="string">'J - columns'</span>);ylabel(<span class="string">'I - rows'</span>); zlabel(<span class="string">'K - slices'</span>); hold <span class="string">on</span>;
slice(M,[],[],S);
axisGeom(gca,fontSize);
colormap(cMap); caxis([min(M(:)) max(M(:))]);
axisGeom(gca,fontSize); view(2);

subplot(2,2,3);
title(<span class="string">'im2patch function'</span>);
xlabel(<span class="string">'J - columns'</span>);ylabel(<span class="string">'I - rows'</span>); zlabel(<span class="string">'K - slices'</span>); hold <span class="string">on</span>;
gpatch(F,V,C);
colormap(cMap); caxis([min(M(:)) max(M(:))]);
axisGeom(gca,fontSize); view(2);

subplot(2,2,4);
title(<span class="string">'MATLAB pcolor function'</span>);
xlabel(<span class="string">'J - columns'</span>);ylabel(<span class="string">'I - rows'</span>); zlabel(<span class="string">'K - slices'</span>); hold <span class="string">on</span>;
pcolor(M(:,:,S));
colormap(cMap); caxis([min(M(:)) max(M(:))]);
axisGeom(gca,fontSize); view(2);

drawnow;
</pre><img width="100%" height="auto" vspace="5" hspace="5" src="HELP_im2patch_05.jpg" alt=""> <p>Note that the image size is wrong for the <tt>slice</tt> and <tt>pcolor</tt> commands. This is because intensities appear to be defined on voxels vertices (and are reinterpolated onto faces) for these functions instead of voxels centres as should be the case for image data.</p><h2 id="17">Example: Creating and plotting combined voxel and slice patch data</h2><p>Simulating 3D image</p><pre class="codeinput">[X,Y,Z]=meshgrid(linspace(-4.77,4.77,25));
phi=(1+sqrt(5))/2;
M=1/6*(2 - (cos(X + phi*Y) + cos(X - phi*Y) + cos(Y + phi*Z) + cos(Y - phi*Z) + cos(Z - phi*X) + cos(Z + phi*X)));
</pre><p>Creating and plotting patch data. Last example illustrates the use of a specific logic description (i.e. a mask) for the voxels of interest</p><pre class="codeinput">cFigure;
title(<span class="string">'Combined voxel and slice plotting'</span>);
xlabel(<span class="string">'J - columns'</span>);ylabel(<span class="string">'I - rows'</span>); zlabel(<span class="string">'K - slices'</span>); hold <span class="string">on</span>;

<span class="comment">% Setting up indices for I direction slices</span>
S=round(size(M,1)./2); <span class="comment">%Selection of middle slice</span>
L_plot=false(size(M)); L_plot(S,:,:)=1;
indPatch=find(L_plot);
[F,V,C]=im2patch(M,indPatch,<span class="string">'si'</span>); <span class="comment">%Creating patch data for y mid-voxel slices</span>
gpatch(F,V,C,<span class="string">'none'</span>,faceAlpha2);

<span class="comment">% Setting up indices for J direction slices</span>
S=round(size(M,2)./2); <span class="comment">%Selection of middle slice</span>
L_plot=false(size(M)); L_plot(:,S,:)=1;
indPatch=find(L_plot);
[F,V,C]=im2patch(M,indPatch,<span class="string">'sj'</span>); <span class="comment">%Creating patch data for x mid-voxel slices</span>
gpatch(F,V,C,<span class="string">'none'</span>,faceAlpha2);

<span class="comment">% Setting up indices for K direction slices</span>
S=round(size(M,3)./2); <span class="comment">%Selection of middle slice</span>
L_plot=false(size(M)); L_plot(:,:,S)=1;
indPatch=find(L_plot);
[F,V,C]=im2patch(M,indPatch,<span class="string">'sk'</span>); <span class="comment">%Creating patch data for z mid-voxel slices</span>
gpatch(F,V,C,<span class="string">'none'</span>,faceAlpha2);

<span class="comment">% Setting up indices for voxels to plot</span>
L_mask=M&gt;-0.2 &amp; M&lt;0;
[F,V,C]=im2patch(M,L_mask,<span class="string">'vb'</span>); <span class="comment">%Creating patch data for selection of high voxels</span>

gpatch(F,V,C);
colormap(cMap); colorbar; caxis([min(M(:)) max(M(:))]);
axisGeom(gca,fontSize); camlight <span class="string">headlight</span>;
drawnow;
</pre><img width="100%" height="auto" vspace="5" hspace="5" src="HELP_im2patch_06.jpg" alt=""> <h2 id="20">Example: Shrinking patch data through combination with <tt>scalePatch</tt> function</h2><pre class="codeinput"><span class="comment">% Using the function |scalePatch| patch data can be shrunk to aid</span>
<span class="comment">% visualisation (can be a tool to avoid memory costly transparency for</span>
<span class="comment">% instance).</span>

[Ev,Vv,Cv]=im2patch(M,L_mask,<span class="string">'h'</span>); <span class="comment">%This creates a hexahedral element for each voxel</span>
[Evs,Vvs]=scalePatch(Ev,Vv,0.5); <span class="comment">%Apply voxel element scaling</span>
[Fvs,Cvs]=element2patch(Evs,Cv); <span class="comment">%Convert to quad faces for plotting</span>
</pre><p>Plotting the voxels</p><pre class="codeinput">cFigure;
title(<span class="string">'Scaled (shrunk) patch data'</span>);
xlabel(<span class="string">'J - columns'</span>);ylabel(<span class="string">'I - rows'</span>); zlabel(<span class="string">'K - slices'</span>); hold <span class="string">on</span>;
gpatch(Fvs,Vvs,Cvs);
colormap(cMap); colorbar; caxis([min(Cvs(:)) max(Cvs(:))]);
axisGeom(gca,fontSize); camlight <span class="string">headlight</span>;
drawnow;
</pre><img width="100%" height="auto" vspace="5" hspace="5" src="HELP_im2patch_07.jpg" alt=""> <h2 id="22">Example: Medical image data and coordinate manipulation due to voxel size</h2><pre class="codeinput"><span class="comment">% Get a 3D image</span>
load <span class="string">mri</span>;
M=squeeze(D); <span class="comment">%example image data set</span>
v=2./[1,1,.4]; <span class="comment">%example voxel size</span>
</pre><p>The voxels to display can be specified as a list (vector) of voxels numbers (linear indices) or using a mask (logic array).</p><pre class="codeinput"><span class="comment">%Defining row, column and slice indicices for slice patching</span>
sliceIndexI=round(size(M,1)/2); <span class="comment">%(close to) middle row</span>
sliceIndexJ=round(size(M,2)/2); <span class="comment">%(close to) middle column</span>
sliceIndexK=round(size(M,3)/2); <span class="comment">%(close to) middle slice</span>

<span class="comment">%Defining "masks" i.e. logic arrays with ones for voxels of interest</span>
logicSliceI=false(size(M));
logicSliceI(sliceIndexI,:,:)=1;
logicSliceI=logicSliceI &amp; M&gt;0;

logicSliceJ=false(size(M));
logicSliceJ(:,sliceIndexJ,:)=1;
logicSliceJ=logicSliceJ &amp; M&gt;0;

logicSliceK=false(size(M));
logicSliceK(:,:,sliceIndexK)=1;
logicSliceK=logicSliceK &amp; M&gt;0;

<span class="comment">%Defining voxel indices for voxels of interest</span>
T_low=min(M(:))+((max(M(:))-min(M(:)))/10); <span class="comment">%Threshold example</span>
logicVoxels=(M&gt;T_low);
logicVoxels(:,1:sliceIndexJ,:)=0;
</pre><p>Creating patch data The patch data consists of a matrix array defining the faces, a matrix array defining the vertices and a vector for the colour data. The vertices are based on the image coordinates however they are formatted as: [X(:) Y(:) Z(:)]. X relates to columns, Y to rows and Z to slices. Use a function like <tt>im2cart</tt> , or <tt>im2mrcart</tt> to convert image to cartesian coordinates.</p><pre class="codeinput">[Fv,Vv,Cv]=im2patch(M,logicVoxels,<span class="string">'vb'</span>);
[Fx,Vx,Cx]=im2patch(M,logicSliceJ,<span class="string">'sj'</span>);
[Fy,Vy,Cy]=im2patch(M,logicSliceI,<span class="string">'si'</span>);
[Fz,Vz,Cz]=im2patch(M,logicSliceK,<span class="string">'sk'</span>);

<span class="comment">% Convert image coordinates to cartesian coordinates</span>
[Vv(:,1),Vv(:,2),Vv(:,3)]=im2cart(Vv(:,2),Vv(:,1),Vv(:,3),v);
[Vx(:,1),Vx(:,2),Vx(:,3)]=im2cart(Vx(:,2),Vx(:,1),Vx(:,3),v);
[Vy(:,1),Vy(:,2),Vy(:,3)]=im2cart(Vy(:,2),Vy(:,1),Vy(:,3),v);
[Vz(:,1),Vz(:,2),Vz(:,3)]=im2cart(Vz(:,2),Vz(:,1),Vz(:,3),v);
</pre><pre class="codeinput">cFigure;
title(<span class="string">'MRI visualisation, slices and voxels in cartesian coordinates with aid of voxel size'</span>);
xlabel(<span class="string">'X (mm)'</span>);ylabel(<span class="string">'Y (mm)'</span>); zlabel(<span class="string">'Z (mm)'</span>); hold <span class="string">on</span>;
gpatch(Fv,Vv,Cv,edgeColor1,faceAlpha2);
gpatch(Fx,Vx,Cx,edgeColor1,faceAlpha1);
gpatch(Fy,Vy,Cy,edgeColor1,faceAlpha1);
gpatch(Fz,Vz,Cz,edgeColor1,faceAlpha1);
colormap(gray(250)); colorbar;
axisGeom(gca,fontSize); camlight <span class="string">headlight</span>;
drawnow;
</pre><img width="100%" height="auto" vspace="5" hspace="5" src="HELP_im2patch_08.jpg" alt=""> <h2 id="26">Example: Combining colormap and RGB driven patch colours</h2><p>N.B. The figure renderer might have to be set to OPENGL.</p><p>Convert voxels colouring to RGB type, here a simple conversion to a gray scale description is used</p><pre class="codeinput">Cv=(Cv*ones(1,3))./max(Cv(:));
</pre><p>Plotting the voxels</p><pre class="codeinput">cFigure;
title(<span class="string">'MRI visualisation, slices and voxels, colormap and RGB driven respectively'</span>);
xlabel(<span class="string">'X (mm)'</span>);ylabel(<span class="string">'Y (mm)'</span>); zlabel(<span class="string">'Z (mm)'</span>); hold <span class="string">on</span>;

<span class="comment">%RGB driven</span>
gpatch(Fv,Vv,Cv,edgeColor1,faceAlpha2);

<span class="comment">%Colormap driven</span>
gpatch(Fx,Vx,Cx,edgeColor1,faceAlpha1);
gpatch(Fy,Vy,Cy,edgeColor1,faceAlpha1);
gpatch(Fz,Vz,Cz,edgeColor1,faceAlpha1);

colormap(cMap); colorbar;
axisGeom(gca,fontSize); camlight <span class="string">headlight</span>;
drawnow;
</pre><img width="100%" height="auto" vspace="5" hspace="5" src="HELP_im2patch_09.jpg" alt=""> <p><img vspace="5" hspace="5" src="gibbVerySmall.gif" alt=""> </p><p><i><b>GIBBON</b></i> <a href="www.gibboncode.org">www.gibboncode.org</a></p><p><i>Kevin Mattheus Moerman</i>, <a href="gibbon.toolbox@gmail.com">gibbon.toolbox@gmail.com</a></p><p><i><b>GIBBON footer text</b></i></p><p>License: <a href="https://github.com/gibbonCode/GIBBON/blob/master/LICENSE">https://github.com/gibbonCode/GIBBON/blob/master/LICENSE</a></p><p>GIBBON: The Geometry and Image-based Bioengineering add-On. A toolbox for image segmentation, image-based modeling, meshing, and finite element analysis.</p><p>Copyright (C) 2006-2020 Kevin Mattheus Moerman</p><p>This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.</p><p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.</p><p>You should have received a copy of the GNU General Public License along with this program.  If not, see <a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>.</p><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2020a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% im2patch
% Below is a demonstration of the features of the |im2patch| function

%%
clear; close all; clc;

%% Syntax
% |[F,V,C]=im2patch(M,IND,ptype);|

%% Description
% This function generates patch data for 3D images. The patch data is only
% generated for the voxels specified by the indices (logic or linear
% indices). The patch data is created according to the patch type desired
% (e.g. voxel type of slice type).

%% Examples

%%
% Plot settings
cMap=parula(250);
faceAlpha1=1;
faceAlpha2=0.5;
edgeColor1='none';
edgeColor2='none';
fontSize=15; 

%% Example: Introduction to using |im2patch| for voxel plotting
% The voxel for which patch data is to be specified can be defined by
% supplying linear indices or a logic array. 

% Simulating an image
M=rand(3,5,7);
% Example supplying linear indices, here all voxels
indPatch=1:numel(M); 

%%
% Creating patch data for voxel display
[F,V,C]=im2patch(M,indPatch,'v'); 

cFigure;
title('patch type: v');
xlabel('J - columns');ylabel('I - rows'); zlabel('K - slices'); hold on;
gpatch(F,V,C,'k',faceAlpha2);
colormap(cMap); caxis([min(M(:)) max(M(:))]); colorbar; 
axisGeom(gca,fontSize); camlight headlight;
drawnow;

%%
% Study the size of the face and vertex arrays to confirm that the patch
% type |'v'| creates vertices and faces for each voxel. Shared vertices and
% faces are not removed. This option requires the most memory. 
disp(num2str(size(F)));
disp(num2str(size(V)));

%%
% Creating patch data for voxel display with shared vertices and faces
% removed
[F,V,C]=im2patch(M,indPatch,'vu'); 

cFigure;
title('patch type: vu');
xlabel('J - columns');ylabel('I - rows'); zlabel('K - slices'); hold on;
gpatch(F,V,C,'k',faceAlpha2);
colormap(cMap); caxis([min(M(:)) max(M(:))]); colorbar; 
axisGeom(gca,fontSize); camlight headlight;
drawnow;

%%
% Study the size of the face and vertex arrays to confirm that the patch
% type |'vu'| ensures that shared faces and vertices are not shared. Each
% vertex and face is therefore unique. This saves memory with respect to
% using the |'v'| patch type for voxel display. The figures look identical
% except that shared faces may appear less dark when transparency is on
% since now one one face is used. Color information is shared too
% (averaged).
disp(num2str(size(F)));
disp(num2str(size(V)));

%%
% Creating patch data for voxel display with only non-shared faces and
% vertices
[F,V,C]=im2patch(M,indPatch,'vb'); 

cFigure;
title('patch type: vb');
xlabel('J - columns');ylabel('I - rows'); zlabel('K - slices'); hold on;
gpatch(F,V,C,'k',faceAlpha2);
colormap(cMap); caxis([min(M(:)) max(M(:))]); colorbar; 
axisGeom(gca,fontSize); camlight headlight;
drawnow;

%%
% Study the size of the face and vertex arrays to confirm that the patch
% type |'vb'| helps to plot only non-shared vertices and faces. 
% In the case of an enclosed shape filled with voxels thus only the
% boundary faces are displayed. This path type appears no different than
% the other is transparency is not on however it is much lighter on memory
% than the above path types. 
disp(num2str(size(F)));
disp(num2str(size(V)));

%% Example: Introduction to using |im2patch| for slice plotting

cFigure;
title('patch type: si, sj, sk');
xlabel('J - columns');ylabel('I - rows'); zlabel('K - slices'); hold on;

%Setting up indices for I direction slices
S=round(size(M,1)./2); %Selection of middle slice
L_plot=false(size(M)); L_plot(S,:,:)=1;
indPatch=find(L_plot);
[F,V,C]=im2patch(M,indPatch,'si'); %Creating patch data for y mid-voxel slices
gpatch(F,V,C);

%Setting up indices for J direction slices
S=round(size(M,2)./2); %Selection of middle slice
L_plot=false(size(M)); L_plot(:,S,:)=1;
indPatch=find(L_plot);
[F,V,C]=im2patch(M,indPatch,'sj'); %Creating patch data for x mid-voxel slices
gpatch(F,V,C);

%Setting up indices for Z direction slices
S=round(size(M,3)./2); %Selection of middle slice
L_plot=false(size(M)); L_plot(:,:,S)=1;
indPatch=find(L_plot);
[F,V,C]=im2patch(M,indPatch,'sk'); %Creating patch data for z mid-voxel slices
gpatch(F,V,C);

colormap(cMap); caxis([min(M(:)) max(M(:))]); colorbar; 
axisGeom(gca,fontSize); camlight headlight;

drawnow;

%%
% The path type s*u are simular to s* but use shared vertices

%% Example: Comparison to standard MATLAB |imagesc| function and the patch type MATLAB functions |slice| and |pcolor|
% The comparison is what motivates the choice of coordinate system for
% im2patch i.e. that it is meant to aid in the visualization of image data
% as is expected of image data. 

cFigure;
subplot(2,2,1);
title('MATLAB imagesc function');
xlabel('J - columns');ylabel('I - rows'); zlabel('K - slices'); hold on;
imagesc(M(:,:,S));
colormap(cMap); caxis([min(M(:)) max(M(:))]);
axisGeom(gca,fontSize); view(2);

subplot(2,2,2);
title('MATLAB slice function');
xlabel('J - columns');ylabel('I - rows'); zlabel('K - slices'); hold on;
slice(M,[],[],S);
axisGeom(gca,fontSize);
colormap(cMap); caxis([min(M(:)) max(M(:))]);
axisGeom(gca,fontSize); view(2);

subplot(2,2,3);
title('im2patch function');
xlabel('J - columns');ylabel('I - rows'); zlabel('K - slices'); hold on;
gpatch(F,V,C);
colormap(cMap); caxis([min(M(:)) max(M(:))]);
axisGeom(gca,fontSize); view(2);

subplot(2,2,4);
title('MATLAB pcolor function');
xlabel('J - columns');ylabel('I - rows'); zlabel('K - slices'); hold on;
pcolor(M(:,:,S));
colormap(cMap); caxis([min(M(:)) max(M(:))]);
axisGeom(gca,fontSize); view(2);

drawnow;

%%
% Note that the image size is wrong for the |slice| and |pcolor| commands.
% This is because intensities appear to be defined on voxels vertices (and
% are reinterpolated onto faces) for these functions instead of voxels
% centres as should be the case for image data. 

%% Example: Creating and plotting combined voxel and slice patch data

%%
% Simulating 3D image
[X,Y,Z]=meshgrid(linspace(-4.77,4.77,25));
phi=(1+sqrt(5))/2;
M=1/6*(2 - (cos(X + phi*Y) + cos(X - phi*Y) + cos(Y + phi*Z) + cos(Y - phi*Z) + cos(Z - phi*X) + cos(Z + phi*X)));

%%
% Creating and plotting patch data. Last example illustrates the use of a
% specific logic description (i.e. a mask) for the voxels of interest

cFigure;
title('Combined voxel and slice plotting');
xlabel('J - columns');ylabel('I - rows'); zlabel('K - slices'); hold on;

% Setting up indices for I direction slices
S=round(size(M,1)./2); %Selection of middle slice
L_plot=false(size(M)); L_plot(S,:,:)=1;
indPatch=find(L_plot);
[F,V,C]=im2patch(M,indPatch,'si'); %Creating patch data for y mid-voxel slices
gpatch(F,V,C,'none',faceAlpha2);

% Setting up indices for J direction slices
S=round(size(M,2)./2); %Selection of middle slice
L_plot=false(size(M)); L_plot(:,S,:)=1;
indPatch=find(L_plot);
[F,V,C]=im2patch(M,indPatch,'sj'); %Creating patch data for x mid-voxel slices
gpatch(F,V,C,'none',faceAlpha2);

% Setting up indices for K direction slices
S=round(size(M,3)./2); %Selection of middle slice
L_plot=false(size(M)); L_plot(:,:,S)=1;
indPatch=find(L_plot);
[F,V,C]=im2patch(M,indPatch,'sk'); %Creating patch data for z mid-voxel slices
gpatch(F,V,C,'none',faceAlpha2);

% Setting up indices for voxels to plot
L_mask=M>-0.2 & M<0;
[F,V,C]=im2patch(M,L_mask,'vb'); %Creating patch data for selection of high voxels

gpatch(F,V,C);
colormap(cMap); colorbar; caxis([min(M(:)) max(M(:))]); 
axisGeom(gca,fontSize); camlight headlight;
drawnow;

%% Example: Shrinking patch data through combination with |scalePatch| function

% Using the function |scalePatch| patch data can be shrunk to aid
% visualisation (can be a tool to avoid memory costly transparency for
% instance).

[Ev,Vv,Cv]=im2patch(M,L_mask,'h'); %This creates a hexahedral element for each voxel
[Evs,Vvs]=scalePatch(Ev,Vv,0.5); %Apply voxel element scaling
[Fvs,Cvs]=element2patch(Evs,Cv); %Convert to quad faces for plotting

%%
% Plotting the voxels
cFigure;
title('Scaled (shrunk) patch data');
xlabel('J - columns');ylabel('I - rows'); zlabel('K - slices'); hold on;
gpatch(Fvs,Vvs,Cvs);
colormap(cMap); colorbar; caxis([min(Cvs(:)) max(Cvs(:))]); 
axisGeom(gca,fontSize); camlight headlight;
drawnow;

%% Example: Medical image data and coordinate manipulation due to voxel size

% Get a 3D image
load mri;
M=squeeze(D); %example image data set
v=2./[1,1,.4]; %example voxel size

%%
% The voxels to display can be specified as a list (vector) of voxels
% numbers (linear indices) or using a mask (logic array).

%Defining row, column and slice indicices for slice patching
sliceIndexI=round(size(M,1)/2); %(close to) middle row
sliceIndexJ=round(size(M,2)/2); %(close to) middle column
sliceIndexK=round(size(M,3)/2); %(close to) middle slice

%Defining "masks" i.e. logic arrays with ones for voxels of interest
logicSliceI=false(size(M)); 
logicSliceI(sliceIndexI,:,:)=1;
logicSliceI=logicSliceI & M>0;

logicSliceJ=false(size(M)); 
logicSliceJ(:,sliceIndexJ,:)=1;
logicSliceJ=logicSliceJ & M>0;

logicSliceK=false(size(M)); 
logicSliceK(:,:,sliceIndexK)=1;
logicSliceK=logicSliceK & M>0;

%Defining voxel indices for voxels of interest
T_low=min(M(:))+((max(M(:))-min(M(:)))/10); %Threshold example
logicVoxels=(M>T_low);
logicVoxels(:,1:sliceIndexJ,:)=0;

%%
% Creating patch data
% The patch data consists of a matrix array defining the faces, a matrix
% array defining the vertices and a vector for the colour data. The
% vertices are based on the image coordinates however they are formatted
% as: [X(:) Y(:) Z(:)]. X relates to columns, Y to rows and Z to slices. 
% Use a function like |im2cart| , or |im2mrcart| to convert image to cartesian
% coordinates. 
 
[Fv,Vv,Cv]=im2patch(M,logicVoxels,'vb'); 
[Fx,Vx,Cx]=im2patch(M,logicSliceJ,'sj');
[Fy,Vy,Cy]=im2patch(M,logicSliceI,'si');
[Fz,Vz,Cz]=im2patch(M,logicSliceK,'sk');

% Convert image coordinates to cartesian coordinates
[Vv(:,1),Vv(:,2),Vv(:,3)]=im2cart(Vv(:,2),Vv(:,1),Vv(:,3),v); 
[Vx(:,1),Vx(:,2),Vx(:,3)]=im2cart(Vx(:,2),Vx(:,1),Vx(:,3),v);
[Vy(:,1),Vy(:,2),Vy(:,3)]=im2cart(Vy(:,2),Vy(:,1),Vy(:,3),v);
[Vz(:,1),Vz(:,2),Vz(:,3)]=im2cart(Vz(:,2),Vz(:,1),Vz(:,3),v);

%%
% 
cFigure;
title('MRI visualisation, slices and voxels in cartesian coordinates with aid of voxel size');
xlabel('X (mm)');ylabel('Y (mm)'); zlabel('Z (mm)'); hold on;
gpatch(Fv,Vv,Cv,edgeColor1,faceAlpha2);
gpatch(Fx,Vx,Cx,edgeColor1,faceAlpha1);
gpatch(Fy,Vy,Cy,edgeColor1,faceAlpha1);
gpatch(Fz,Vz,Cz,edgeColor1,faceAlpha1);
colormap(gray(250)); colorbar; 
axisGeom(gca,fontSize); camlight headlight;
drawnow;

%% Example: Combining colormap and RGB driven patch colours 
% N.B. The figure renderer might have to be set to OPENGL.

%%
% Convert voxels colouring to RGB type, here a simple conversion to a gray
% scale description is used
Cv=(Cv*ones(1,3))./max(Cv(:)); 

%%
% Plotting the voxels

cFigure;
title('MRI visualisation, slices and voxels, colormap and RGB driven respectively');
xlabel('X (mm)');ylabel('Y (mm)'); zlabel('Z (mm)'); hold on;

%RGB driven
gpatch(Fv,Vv,Cv,edgeColor1,faceAlpha2);

%Colormap driven
gpatch(Fx,Vx,Cx,edgeColor1,faceAlpha1);
gpatch(Fy,Vy,Cy,edgeColor1,faceAlpha1);
gpatch(Fz,Vz,Cz,edgeColor1,faceAlpha1);

colormap(cMap); colorbar; 
axisGeom(gca,fontSize); camlight headlight;
drawnow;

%% 
%
% <<gibbVerySmall.gif>>
% 
% _*GIBBON*_ 
% <www.gibboncode.org>
% 
% _Kevin Mattheus Moerman_, <gibbon.toolbox@gmail.com>
 
%% 
% _*GIBBON footer text*_ 
% 
% License: <https://github.com/gibbonCode/GIBBON/blob/master/LICENSE>
% 
% GIBBON: The Geometry and Image-based Bioengineering add-On. A toolbox for
% image segmentation, image-based modeling, meshing, and finite element
% analysis.
% 
% Copyright (C) 2006-2020 Kevin Mattheus Moerman
% 
% This program is free software: you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation, either version 3 of the License, or
% (at your option) any later version.
% 
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License
% along with this program.  If not, see <http://www.gnu.org/licenses/>.

##### SOURCE END #####
--></body></html>
